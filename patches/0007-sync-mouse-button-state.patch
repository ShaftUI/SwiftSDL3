diff --git a/Sources/SwiftSDL3/src/video/cocoa/SDL_cocoawindow.m b/Sources/SwiftSDL3/src/video/cocoa/SDL_cocoawindow.m
index 3425737..eb0a807 100644
--- a/Sources/SwiftSDL3/src/video/cocoa/SDL_cocoawindow.m
+++ b/Sources/SwiftSDL3/src/video/cocoa/SDL_cocoawindow.m
@@ -1703,12 +1703,68 @@ - (BOOL)processHitTest:(NSEvent *)theEvent
     return NO; // not a special area, carry on.
 }
 
+static void Cocoa_SyncMouseButtonState(SDL_Mouse *mouse, SDL_MouseID mouseID, Uint8 excludeButton)
+{
+    const NSUInteger actualButtons = [NSEvent pressedMouseButtons];
+    SDL_MouseInputSource *source = NULL;
+    
+    // Find the mouse input source
+    for (int i = 0; i < mouse->num_sources; ++i) {
+        if (mouse->sources[i].mouseID == mouseID) {
+            source = &mouse->sources[i];
+            break;
+        }
+    }
+    
+    if (!source) {
+        return;  // No source yet, will be created by the actual event
+    }
+    
+    Uint32 sdlButtonState = source->buttonstate;
+    Uint32 actualButtonState = 0;
+    
+    // Convert NSEvent button mask to SDL button mask
+    if (actualButtons & (1 << 0)) {
+        actualButtonState |= SDL_BUTTON_LMASK;
+    }
+    if (actualButtons & (1 << 1)) {
+        actualButtonState |= SDL_BUTTON_RMASK;
+    }
+    if (actualButtons & (1 << 2)) {
+        actualButtonState |= SDL_BUTTON_MMASK;
+    }
+    if (actualButtons & (1 << 3)) {
+        actualButtonState |= SDL_BUTTON_X1MASK;
+    }
+    if (actualButtons & (1 << 4)) {
+        actualButtonState |= SDL_BUTTON_X2MASK;
+    }
+    
+    // Sync any buttons that are out of sync (except the one being processed)
+    for (Uint8 button = SDL_BUTTON_LEFT; button <= SDL_BUTTON_X2; ++button) {
+        // Skip the button being processed to avoid duplicate events
+        if (excludeButton != 0 && button == excludeButton) {
+            continue;
+        }
+        
+        Uint32 buttonMask = SDL_BUTTON_MASK(button);
+        bool sdlPressed = (sdlButtonState & buttonMask) != 0;
+        bool actuallyPressed = (actualButtonState & buttonMask) != 0;
+        
+        if (sdlPressed != actuallyPressed) {
+            // Send synthetic event to sync state
+            SDL_SendMouseButton(0, mouse->focus, mouseID, button, actuallyPressed);
+        }
+    }
+}
+
 static void Cocoa_SendMouseButtonClicks(SDL_Mouse *mouse, NSEvent *theEvent, SDL_Window *window, Uint8 button, bool down)
 {
     SDL_MouseID mouseID = SDL_DEFAULT_MOUSE_ID;
     //const int clicks = (int)[theEvent clickCount];
     SDL_Window *focus = SDL_GetKeyboardFocus();
 
+    // Sync button state with hardware before processing event (exclude the button being processed to avoid duplicate events)
+    Cocoa_SyncMouseButtonState(mouse, mouseID, button);
+
     // macOS will send non-left clicks to background windows without raising them, so we need to
     //  temporarily adjust the mouse position when this happens, as `mouse` will be tracking
     //  the position in the currently-focused window. We don't (currently) send a mousemove
